# 스택/큐

[toc]

## 프로그래머스_기능개발

> [프로그래머스_기능개발](https://programmers.co.kr/learn/courses/30/lessons/42586?language=python3)

- `Python3`

```python
'''
progresses에서 앞에서 뽑아서 speeds의 앞에서 뽑은것만큼 더함 며칠 걸리는지 확인
앞의 진행상황을 일수가 아직 끝나지 않으면 뒤에 것이 끝나더라도 나중에 배포

'''
def solution(progresses, speeds):
    answer = []
    days = []
    for i in range(len(progresses)):
        day = 0
        progress = progresses[i]
        speed = speeds[i]
        while progress < 100:
            progress += speed
            day += 1
        days.append(day)
    print(days)
    start = days.pop(0)
    cnt = 1
    while True:
        if days:
            next = days.pop(0)
        else:
            answer.append(cnt)
            break
        if start >= next:
            cnt += 1
        else:
            start = next
            answer.append(cnt)
            cnt = 1
    return answer

```

- `Javascript`

```javascript
function solution(progresses, speeds) {
    const answer = [];
    let time = 0;
    let cnt = 0;
    while (progresses.length > 0) {
      if ((progresses[0] + (time * speeds[0])) >= 100 ) {
          cnt += 1;
          progresses.shift();
          speeds.shift();
      }  else {
          if ( cnt > 0 ) {
              answer.push(cnt);
              cnt = 0;
          }
          time += 1;
      }
    };
    answer.push(cnt);
    return answer;
}
```



- 다른 코드(`Python3`)

```python
def solution(progresses, speeds):
    Q=[]
    for p, s in zip(progresses, speeds):
        if len(Q)==0 or Q[-1][0]<-((p-100)//s):
            Q.append([-((p-100)//s),1])
        else:
            Q[-1][1]+=1
    return [q[1] for q in Q]
```

```python
def solution(progresses, speeds):
    print(progresses)
    print(speeds)
    answer = []
    time = 0
    count = 0
    while len(progresses)> 0:
        if (progresses[0] + time*speeds[0]) >= 100:
            progresses.pop(0)
            speeds.pop(0)
            count += 1
        else:
            if count > 0:
                answer.append(count)
                count = 0
            time += 1
    answer.append(count)
    return answer
```

- 다른풀이(`Javascript`)

```javascript
function solution(progresses, speeds) {
    let answer = [0];
    let days = progresses.map((progress, index) => Math.ceil((100 - progress) / speeds[index]));
    let maxDay = days[0];

    for(let i = 0, j = 0; i< days.length; i++){
        if(days[i] <= maxDay) {
            answer[j] += 1;
        } else {
            maxDay = days[i];
            answer[++j] = 1;
        }
    }

    return answer;
}
```



```javascript
function solution(progresses, speeds) {
    var answer = [];

    while(speeds.length > 0) {
        // 개발
        for(let i in speeds) {
            if(progresses[i] < 100) {
                progresses[i] += speeds[i];
            }
        }

        // 배포
        let deploy_count = 0;
        while(progresses[0] >= 100) {
            progresses.shift();
            speeds.shift();
            deploy_count++;
        }
        if(deploy_count > 0) {
            answer.push(deploy_count);
        }
    }

    return answer;
}
```



## 프로그래머스_프린터

> [프로그래머스_프린터](https://programmers.co.kr/learn/courses/30/lessons/42587)

```python
'''
1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
3. 그렇지 않으면 J를 인쇄합니다.
4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄
숫자가 클수록 중요도가 높다
location은 대기 목록의 가장 앞에 있으면 0두번쨰에 있으면 1(0~현재 대기목록에 있는작업수-1)
중요도 담긴 배열 priorities, 인쇄 요청 문서가 현재 대기 목록의 어떤 위치에 있는지 알려주는 location 주어짐

1. priorities에서 제일 앞에가 max값이 나올때 그걸 pop해서 result에 append, location - 1(만약 location이 -1이되면 들어간것!(result의 len이 값))
2. 만약 location이 0이되면 location = len(priorities) - 1 크면, location -1
'''
def solution(priorities, location):
    answer = 0
    result = []
    while location != -1:
        MAX = max(priorities)
        if priorities[0] != MAX:
            priorities.append(priorities.pop(0))
            if location == 0:
                location = len(priorities) - 1
            else:
                location -= 1
        else:
            result.append(priorities.pop(0))
            location -= 1
    answer = len(result)
    return answer
```

- 다른풀이

> ### any vs all
>
> #### all
>
> - **all(iterable)** 함수는 인자로 받은 **반복 가능한 자료형(iterable)의 모든 요소**가 참(True)이면 참(True)을 반환하는 함수
>
> #### any
>
> - **any(iterable) 함수는** **인자로 받은** **반복가능한 자료형(iterable)중 단 하나라도 참(True)이 있으면 참(True)를 반환**하는 함수 입니다. **반대로 모든 요소가 거짓(False)인 경우에만 거짓(False)을 반환합니다.**

```python
def solution(priorities, location):
    queue =  [(i,p) for i,p in enumerate(priorities)]
    answer = 0
    while True:
        cur = queue.pop(0)
        if any(cur[1] < q[1] for q in queue):
            queue.append(cur)
        else:
            answer += 1
            if cur[0] == location:
                return answer
```



## 프로그래머스_다리를지나는트럭

> [프로그래머스_다리를지나는트럭](https://programmers.co.kr/learn/courses/30/lessons/42583)

```python
'''
bridge_length에서 weight까지 견디는 다리가 있다 최소 몇초?
1. 트럭 배열에서 다리로 올릴 때 다리에 sum, len 확인후 sum + 해당트럭무게<=weight, len< bridge_length이면 올리기
2. 만약 올릴수 없다면 0을 올림
3. time+1을 하는데, len(bridge)가 bridge_length면 제일 앞에것 pop,
'''
def solution(bridge_length, weight, truck_weights):
    answer = 0
    bridge = [0]*(bridge_length)
    SUM = 0
    while bridge:
        answer += 1
        SUM -= bridge.pop(0)
#         다리에 올라갈 수 있음
# if truck_weights and SUM + truck_weights[0] <= weight: 이렇게 하면 시간초과 WHY??
        if truck_weights:
            if SUM + truck_weights[0] <= weight:
                truck = truck_weights.pop(0)
                SUM += truck
                bridge.append(truck)
            else:
                bridge.append(0)
        
    return answer
```

- 다른코드

```python
import collections

DUMMY_TRUCK = 0


class Bridge(object):

    def __init__(self, length, weight):
        self._max_length = length
        self._max_weight = weight
        self._queue = collections.deque()
        self._current_weight = 0

    def push(self, truck):
        next_weight = self._current_weight + truck
        if next_weight <= self._max_weight and len(self._queue) < self._max_length:
            self._queue.append(truck)
            self._current_weight = next_weight
            return True
        else:
            return False

    def pop(self):
        item = self._queue.popleft()
        self._current_weight -= item
        return item

    def __len__(self):
        return len(self._queue)

    def __repr__(self):
        return 'Bridge({}/{} : [{}])'.format(self._current_weight, self._max_weight, list(self._queue))


def solution(bridge_length, weight, truck_weights):
    bridge = Bridge(bridge_length, weight)
    trucks = collections.deque(w for w in truck_weights)

    for _ in range(bridge_length):
        bridge.push(DUMMY_TRUCK)

    count = 0
    while trucks:
        bridge.pop()

        if bridge.push(trucks[0]):
            trucks.popleft()
        else:
            bridge.push(DUMMY_TRUCK)

        count += 1

    while bridge:
        bridge.pop()
        count += 1

    return count


def main():
    print(solution(2, 10, [7, 4, 5, 6]), 8)
    print(solution(100, 100, [10]), 101)
    print(solution(100, 100, [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]), 110)


if __name__ == '__main__':
    main()
```



## 프로그래머스_주식가격

> [프로그래머스_주식가격](https://programmers.co.kr/learn/courses/30/lessons/42584?language=python3)

- 이렇게 풀면 답은 모두 맞지만 효율성은 0

> ![image-20210702211001773](스택큐.assets/image-20210702211001773.png)

```python
'''
가격이 떨어지지 않는 기간은 몇초?
prices는 초단위로 기록된 주식가격이 담긴 배열
자기보다 뒤에서 자기자신보다 작은 수가 나오면 가격이 떨어진것
1. prices를 pop해서 쭉 뒤로 보면서 자기보다 작은 것이 나오면 초수를 answer에 담아줌
'''
def solution(prices):
    answer = []
    
    while prices:
        now = prices.pop(0)
        sec = 0
        for next in prices:
            sec += 1
            if now > next:
                break
        answer.append(sec)
            
    return answer
```

- 효율성 통과

> ![image-20210702211521212](스택큐.assets/image-20210702211521212.png)

```python
def solution(prices):
    answer = []
    for i in range(len(prices)):
        sec = 0
        for j in range(i+1,len(prices)):
            sec += 1
            if prices[i] > prices[j]:
                break
        answer.append(sec)
    return answer
```





## BOJ_10828_스택

> [BOJ_10828_스택](https://www.acmicpc.net/problem/10828)

```python
'''
정수를 저장하는 스택,
스택은 LIFO(마지막에 들어간것이 먼저나감)
push X : X를 스택에 넣는 연산
pop : 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력, 만약 스택에 들어있는 정수가 없는 경우 -1 출력
size : 스택에 들어있는 정수의 개수 출력
empty : 스택이 비어있으면 1, 아니면 0 출력
top : 스택의 가장 위에 있는 정수 출력, 만약 없으면 -1
'''
import sys
input = sys.stdin.readline

N = int(input())
stack = []
for _ in range(N):
    order = input()
    if "push" in order:
        stack.append(int(order[5:]))
    elif "pop" in order:
        if stack:
            print(stack.pop())
        else:
            print(-1)
    elif "size" in order:
        print(len(stack))
    elif "empty" in order:
        if stack:
            print(0)
        else:
            print(1)
    elif "top" in order:
        if stack:
            print(stack[-1])
        else:
            print(-1)
    #print(order,stack)
```

- 다른 코드

```python
from sys import stdin

stack = []
next(stdin)
for line in stdin:
    command = line.split()
    if command[0] == 'push':
        stack.append(command[1])
    elif command[0] == 'pop':
        if stack: print(stack.pop())
        else: print(-1)
    elif command[0] == 'size':
        print(len(stack))
    elif command[0] == 'empty':
        if stack: print(0)
        else: print(1)
    elif command[0] == 'top':
        if stack: print(stack[-1])
        else: print(-1)
```



## BOJ_2493_탑

> [BOJ_2493_탑](https://www.acmicpc.net/problem/2493)

```python
'''
리스트의 오른쪽부터 왼쪽방향으로 레이저 발사,
출력 : 몇번쨰 탑이 신호를 받는지
1. 리스트를 뒤에서부터 보는데 그앞의 수가 자기보다 같거나 커야 수신받음!, 만약 없다면 0
'''
# 시간초과
import sys
input = sys.stdin.readline

N = int(input())
top = list(map(int,input().split()))
answer = []
for i in range(N-1,-1,-1):
    now = top[i]
    idx = i-1
    ans = 0
    while idx >= 0:
        next = top[idx]
        if now <= next:
            ans = idx + 1
            break
        else:
            idx -= 1
    answer.append(ans)
answer.reverse()
print(*answer)

```

