# 선점형 SFJ 스케쥴링

[출처](https://velog.io/@hyun0310woo/6.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A0%EC%A0%90%ED%98%95%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95)

>shortest-job-first scheduling; SJF scheduling
>
>최단 작업 우선 스케줄링; SJF 스케줄링, SJF 알고리즘

- 버스트 시간이 짧은 프로세스부터 CPU 할당
- 버스트 시간이 짧은 것을 우선 처리하는 스케줄링 방식
- 버스트 시간이 짧을수록 우선순위를 높게 책정하는 [우선순위 스케줄링](https://zetawiki.com/wiki/우선순위_스케줄링)
- 버스트 시간이 같으면 [FCFS 스케줄링](https://zetawiki.com/wiki/FCFS_스케줄링)
- [비선점형](https://zetawiki.com/wiki/비선점형), [선점형](https://zetawiki.com/wiki/선점형) 모두 가능

### 결정 시점

CPU 스케줄링의 결정 시점은 다음과 같은 프로세스의 **상태 변화**가 있을 때이다.

![img](선점형_SFJ_스케쥴링.assets/image.png)

1. 수행 → 대기

2. 수행 → 준비

3. 대기 → 준비

4. 수행 → 종료

**스케줄링 적용 시점에 따라 비선점형과 선점형의 2가지로 구분**할 수 있다. **비선점형은 위의 결정 시점 중 1번과 4번의 상황에서만 수행**되며, **선점형은 1번에서 4번까지 모든 상황에서 수행**된다.

**비선점형 스케줄링(Non-preemptive Scheduling)** : 어떤 **프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 입출력 요구가 발생하여 `자발적`으로 중지될 때까지 계속 실행되도록 보장**한다. 순서대로 처리되는 공정성이 있고 다음에 처리해야 할 프로세스와 관계없이 응답 시간을 예상할 수 있으며 선점 방식보다 스케줄러 호출 빈도가 낮고 문맥 교환에 의한 오버헤드가 적다. 일괄 처리 시스템에 적합하며, CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 오랫동안 대기시킬 수 있으므로, 처리율이 떨어질 수 있다는 단점이 있다.

**선점형 스케줄링(Preemptive Scheduling)** : 어떤 **프로세스가 CPU를 할당받아 실행 중에 있어도 다른 프로세스가 실행 중인 프로세스를 중지하고 CPU를 `강제로` 점유**할 수 있다. 모든 프로세스에게 CPU 사용 시간을 동일하게 부여할 수 있다. 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세서를 제어할 수 있다. **운영 체제가 프로세서 자원을 선점**하고 있다가 각 프로세스의 요청이 있을 때 특정 요건들을 기준으로 자원을 배분하는 방식이다.