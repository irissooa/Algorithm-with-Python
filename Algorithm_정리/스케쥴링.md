# 스케쥴링알고리즘

[toc]

## 스케쥴링 알고리즘

스케줄링(scheduling)이란 **운영체제가 여러 프로세스의 CPU 할당 순서를 결정**하는 것입니다. 이 일을 하는 프로그램을 스케줄러라고 합니다.

스케줄링은 CPU를 언제 할당하는지에 따라 선점형 스케줄링(preemptive scheduling)과 비선점형 스케줄링(non-preemptive scheduling)으로 나눌 수 있습니다.

**선점형 스케줄링**에서는 어떤 프로세스가 실행 중에 있어도 스케줄러가 강제로 실행을 중지하고 다른 프로세스에 CPU를 할당할 수 있습니다. 이에 반해 **비선점형 스케줄링**에서는 실행 중인 프로세스가 종료되거나 I/O 작업에 들어가거나 명시적으로 CPU를 반환하기 전까지 계속해서 실행됩니다. 우선순위가 높은 프로세스가 생성되어도 실행 중인 프로세스가 자발적으로 CPU를 양보하기 전까지는 실행될 수 없습니다. 윈도를 포함한 최근 운영체제는 멀티태스킹을 위해 선점형 스케줄링을 합니다.



**1|** **우선순위(Priority) 알고리즘** 

> - 프로세스에 우선순위를 매겨 우선순위가 높은 프로세스를 먼저 실행.
> - 단점 -기아 상태(starvation) 발생
>   - 우선순위가 낮은 프로세스는 계속 CPU를 할당받지 못하는 현상
> - 위와 같은 문제를 해결하기 위해 만든 방법 - 에이징(aging)
>   - 우선순위가 낮은 프로세스가 일정 시간 CPU를 할당받지 못하면 우선순위를 높여 실행

프로세스에 우선순위를 매겨 우선순위가 높은 프로세스를 먼저 실행합니다. 어떤 프로세스가 CPU를 할당받고 실행되는 도중에 우선순위가 높은 프로세스가 생성되면 스케줄러는 실행 중인 프로세스를 실행 가능 상태로 만들고 우선순위가 높은 프로세스를 실행합니다. 계속해서 우선순위가 높은 프로세스가 생성되면 우선순위가 낮은 프로세스는 계속 CPU를 할당받지 못하는 현상이 발생하는데 이를 **기아 상태(starvation)**라고 합니다. 이를 해결하기 위해 우선순위가 낮은 프로세스가 일정 시간 CPU를 할당받지 못하면 우선순위를 높여 실행될 수 있도록 만드는데 이러한 방법을 **에이징(aging)**이라고 합니다.

**2|** **라운드 로빈(Round-Robin) 알고리즘** 

> - 실행 가능 상태에 있는 프로세스들을 순서대로 가져와 일정 시간동안 CPU를 할당하는 방식
> - **타임 슬라이스(time slice) 혹은 퀀텀(quantum)** - 프로세스에 부여된 일정 시간
> - **대표적인 선점형 스케줄링**
> - 단점
>   - 너무 짧으면 컨텍스트 스위칭이 자주 일어나 시스템에 부담이 됨
>   - 너무 길면 멀티태스킹을 구현하는데 문제가 발생

실행 가능 상태에 있는 프로세스들을 순서대로 가져와 일정 시간 동안 CPU를 할당하는 방식입니다. 모든 프로세스에 같은 시간이 부여됩니다. 이때 프로세스에 부여된 일정 시간을 타임 슬라이스(time slice) 혹은 퀀텀(quantum)이라고 합니다. 라운드 로빈을 이용하면 모든 프로세스가 동시에 실행되는 것처럼 보입니다. 대표적인 선점형 스케줄링입니다. 라운드 로빈 스케줄링에서 가장 중요한 것은 타임 슬라이스를 얼마로 정하느냐입니다. 너무 짧으면 다음 절에서 배울 컨텍스트 스위칭이 너무 자주 일어나 시스템에 부담이 되고 너무 길면 멀티태스킹을 구현하는 데 문제가 발생합니다.

**3|** **FCFS(First Come First Served)** 

> - 실행 가능 상태에 먼저 들어온 프로세스를 먼저 실행
> - **비선점형 스케줄링**

실행 가능 상태에 먼저 들어온 프로세스를 먼저 실행하는 방법입니다. 비선점 스케줄링입니다.

**4|** **SJF(Shortest** **Job First)** 

> - 평균 대기 시간을 최소화하기 위해 CPU 할당 시간이 가장 짧은 프로세스를 먼저 실행
> - 단점
>   - 할당 시간이 긴 프로세스는 계속해서 실행이 되지 않는 기아 상태에 빠질수 있다.
>   - CPU의 실제 할당 시간을 알 수 없으므로 예측에 의존해야 하는 단점도 있다.

평균 대기 시간을 최소화하기 위해 CPU 할당 시간이 가장 짧은 프로세스를 먼저 실행합니다. 우선순위 알고리즘처럼 할당 시간이 긴 프로세스는 계속해서 실행이 되지 않는 기아 상태에 빠질 수 있습니다. 또한 CPU의 실제 할당 시간을 알 수 없으므로 예측에 의존해야 하는 단점도 있습니다.

## SFJ코드

> 도착시간과 CPU 사용 시간만 주어 졌을 때 대기시간(Wating Time)을 구해 봅시다.
>
> **BT** = Burst Time(CPU 사용 시간)
> **AT** = Arrival Time(도착시간) Process가 Ready Queue에 들어온 시간
> **WT** = Wating Time(대기시간) Process가 Ready Queue에서 기다리는 총 시간
> **TAT** = Turn Around Time(반환시간) 프로세스가 시작해서 끝날 때까지 걸리는 시간
> **CT** = Completion Time(완료시간)
> **Pn** = Process Number(프로세스 번호) P1, P2...

```python
class Schedule():
        def __init__(self, name, at, bt):
            self.name = name
            self.at = at
            self.bt = bt
            self.ct = 0
        def __repr__(self):
            return '\t'.join([self.name, str(self.at), str(self.bt), str(self.ct)]) + '\n'

def solution(processes):
        pro =  []
        for p in processes:
            pro.append(Schedule(p[0], p[1], p[2]))
        pro.sort(key=lambda x: (x.at, x.bt))
        pro[0].ct = pro[0].bt + pro[0].at

        for j in range(1, len(processes)):
            ab = pro[j-1].ct

            # partial sorting 부분
            waitings = list(filter(lambda x: x.at < ab, pro[j:]))
            pro[j:j+len(waitings)] = sorted(waitings, key=lambda x: x.bt)
            # partial sortings 부분

            if pro[j-1].ct < pro[j].at:
                 pro[j].ct = pro[j-1].ct + pro[j].bt + pro[j].at - pro[j-1].ct
            else:
                 pro[j].ct = pro[j-1].ct + pro[j].bt
        return pro


print(solution([['A', 0, 4], ['B', 3, 2], ['C', 5, 6], ['D', 4, 6], ['E', 5, 7]]))
```





[출처](https://velog.io/@hyun0310woo/6.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A0%EC%A0%90%ED%98%95%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95)

## 정의

>shortest-job-first scheduling; SJF scheduling
>
>최단 작업 우선 스케줄링; SJF 스케줄링, SJF 알고리즘

- 버스트 시간이 짧은 프로세스부터 CPU 할당
- 버스트 시간이 짧은 것을 우선 처리하는 스케줄링 방식
- 버스트 시간이 짧을수록 우선순위를 높게 책정하는 [우선순위 스케줄링](https://zetawiki.com/wiki/우선순위_스케줄링)
- 버스트 시간이 같으면 [FCFS 스케줄링](https://zetawiki.com/wiki/FCFS_스케줄링)
- [비선점형](https://zetawiki.com/wiki/비선점형), [선점형](https://zetawiki.com/wiki/선점형) 모두 가능

### 결정 시점

CPU 스케줄링의 결정 시점은 다음과 같은 프로세스의 **상태 변화**가 있을 때이다.

![img](선점형_SFJ_스케쥴링.assets/image.png)

1. 수행 → 대기

2. 수행 → 준비

3. 대기 → 준비

4. 수행 → 종료

**스케줄링 적용 시점에 따라 비선점형과 선점형의 2가지로 구분**할 수 있다. **비선점형은 위의 결정 시점 중 1번과 4번의 상황에서만 수행**되며, **선점형은 1번에서 4번까지 모든 상황에서 수행**된다.

**비선점형 스케줄링(Non-preemptive Scheduling)** : 어떤 **프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 입출력 요구가 발생하여 `자발적`으로 중지될 때까지 계속 실행되도록 보장**한다. 순서대로 처리되는 공정성이 있고 다음에 처리해야 할 프로세스와 관계없이 응답 시간을 예상할 수 있으며 선점 방식보다 스케줄러 호출 빈도가 낮고 문맥 교환에 의한 오버헤드가 적다. 일괄 처리 시스템에 적합하며, CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 오랫동안 대기시킬 수 있으므로, 처리율이 떨어질 수 있다는 단점이 있다.

**선점형 스케줄링(Preemptive Scheduling)** : 어떤 **프로세스가 CPU를 할당받아 실행 중에 있어도 다른 프로세스가 실행 중인 프로세스를 중지하고 CPU를 `강제로` 점유**할 수 있다. 모든 프로세스에게 CPU 사용 시간을 동일하게 부여할 수 있다. 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세서를 제어할 수 있다. **운영 체제가 프로세서 자원을 선점**하고 있다가 각 프로세스의 요청이 있을 때 특정 요건들을 기준으로 자원을 배분하는 방식이다.